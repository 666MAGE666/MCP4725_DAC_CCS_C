CCS PCM C Compiler, Version 5.049, 5967               31-Ara-23 16:47

               Filename:   C:\Users\ACER\Desktop\MCP4725_DAC_CCS_C\MCP4725_DAC_16f1938.lst

               ROM used:   1845 words (11%)
                           Largest free fragment is 2048
               RAM used:   414 (40%) at main() level
                           511 (50%) worst case
               Stack used: 3 locations
               Stack size: 16

*
0000:  MOVLP  00
0001:  GOTO   701
0002:  NOP
.................... #include <MCP4725_DAC_16f1938.h> 
.................... #include <16F1938.h> 
.................... //////////// Standard Header file for the PIC16F1938 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F1938 
0003:  MOVLW  8E
0004:  MOVWF  77
0005:  MOVLB  06
0006:  MOVF   21,W
0007:  MOVWF  78
0008:  MOVF   20,W
0009:  MOVWF  79
000A:  CLRF   7A
000B:  MOVF   78,F
000C:  BTFSS  03.2
000D:  GOTO   018
000E:  MOVF   79,W
000F:  MOVWF  78
0010:  CLRF   79
0011:  MOVLW  08
0012:  SUBWF  77,F
0013:  MOVF   78,F
0014:  BTFSS  03.2
0015:  GOTO   018
0016:  CLRF   77
0017:  GOTO   020
0018:  BCF    03.0
0019:  BTFSC  78.7
001A:  GOTO   01F
001B:  RLF    79,F
001C:  RLF    78,F
001D:  DECF   77,F
001E:  GOTO   018
001F:  BCF    78.7
0020:  MOVLB  00
0021:  RETURN
0022:  MOVLB  06
0023:  MOVF   20,W
0024:  BTFSC  03.2
0025:  GOTO   093
0026:  MOVWF  2A
0027:  MOVF   24,W
0028:  BTFSC  03.2
0029:  GOTO   093
002A:  ADDWF  2A,F
002B:  BTFSC  03.0
002C:  GOTO   034
002D:  MOVLW  7F
002E:  SUBWF  2A,F
002F:  BTFSS  03.0
0030:  GOTO   093
0031:  BTFSC  03.2
0032:  GOTO   093
0033:  GOTO   038
0034:  MOVLW  81
0035:  ADDWF  2A,F
0036:  BTFSC  03.0
0037:  GOTO   093
0038:  MOVF   2A,W
0039:  MOVWF  77
003A:  CLRF   78
003B:  CLRF   79
003C:  CLRF   7A
003D:  MOVF   21,W
003E:  MOVWF  2E
003F:  BSF    2E.7
0040:  MOVF   22,W
0041:  MOVWF  2D
0042:  MOVF   23,W
0043:  MOVWF  2C
0044:  MOVLW  18
0045:  MOVWF  2A
0046:  CLRF   2B
0047:  BTFSS  2C.0
0048:  GOTO   061
0049:  MOVF   27,W
004A:  ADDWF  7A,F
004B:  BTFSS  03.0
004C:  GOTO   053
004D:  INCF   79,F
004E:  BTFSS  03.2
004F:  GOTO   053
0050:  INCF   78,F
0051:  BTFSC  03.2
0052:  BSF    2B.7
0053:  MOVF   26,W
0054:  ADDWF  79,F
0055:  BTFSS  03.0
0056:  GOTO   05A
0057:  INCF   78,F
0058:  BTFSC  03.2
0059:  BSF    2B.7
005A:  MOVF   25,W
005B:  MOVWF  22
005C:  BSF    22.7
005D:  MOVF   22,W
005E:  ADDWF  78,F
005F:  BTFSC  03.0
0060:  BSF    2B.7
0061:  RLF    2B,F
0062:  RRF    78,F
0063:  RRF    79,F
0064:  RRF    7A,F
0065:  RRF    2E,F
0066:  RRF    2D,F
0067:  RRF    2C,F
0068:  BCF    03.0
0069:  DECFSZ 2A,F
006A:  GOTO   046
006B:  MOVLW  01
006C:  ADDWF  77,F
006D:  BTFSC  03.0
006E:  GOTO   093
006F:  BTFSC  78.7
0070:  GOTO   078
0071:  RLF    2E,F
0072:  RLF    7A,F
0073:  RLF    79,F
0074:  RLF    78,F
0075:  DECF   77,F
0076:  BTFSC  03.2
0077:  GOTO   093
0078:  BTFSS  2E.7
0079:  GOTO   089
007A:  INCF   7A,F
007B:  BTFSS  03.2
007C:  GOTO   089
007D:  INCF   79,F
007E:  BTFSS  03.2
007F:  GOTO   089
0080:  INCF   78,F
0081:  BTFSS  03.2
0082:  GOTO   089
0083:  RRF    78,F
0084:  RRF    79,F
0085:  RRF    7A,F
0086:  INCF   77,F
0087:  BTFSC  03.2
0088:  GOTO   093
0089:  MOVF   21,W
008A:  MOVWF  2B
008B:  MOVF   25,W
008C:  XORWF  2B,F
008D:  BTFSS  2B.7
008E:  GOTO   091
008F:  BSF    78.7
0090:  GOTO   097
0091:  BCF    78.7
0092:  GOTO   097
0093:  CLRF   77
0094:  CLRF   78
0095:  CLRF   79
0096:  CLRF   7A
0097:  MOVLB  00
0098:  RETURN
0099:  MOVLW  80
009A:  BTFSS  03.1
009B:  GOTO   09F
009C:  MOVLB  06
009D:  XORWF  25,F
009E:  MOVLB  00
009F:  MOVLB  06
00A0:  CLRF   2A
00A1:  CLRF   2B
00A2:  MOVF   21,W
00A3:  MOVWF  29
00A4:  MOVF   25,W
00A5:  XORWF  29,F
00A6:  MOVF   20,W
00A7:  BTFSC  03.2
00A8:  GOTO   190
00A9:  MOVWF  28
00AA:  MOVWF  77
00AB:  MOVF   24,W
00AC:  BTFSC  03.2
00AD:  GOTO   199
00AE:  SUBWF  28,F
00AF:  BTFSC  03.2
00B0:  GOTO   134
00B1:  BTFSS  03.0
00B2:  GOTO   0F1
00B3:  MOVF   25,W
00B4:  MOVWF  2E
00B5:  BSF    2E.7
00B6:  MOVF   26,W
00B7:  MOVWF  2D
00B8:  MOVF   27,W
00B9:  MOVWF  2C
00BA:  CLRF   2B
00BB:  BCF    03.0
00BC:  RRF    2E,F
00BD:  RRF    2D,F
00BE:  RRF    2C,F
00BF:  RRF    2B,F
00C0:  DECFSZ 28,F
00C1:  GOTO   0BA
00C2:  BTFSS  29.7
00C3:  GOTO   0C7
00C4:  BSF    2A.0
00C5:  GOTO   1AD
00C6:  BCF    2A.0
00C7:  BCF    28.0
00C8:  BSF    2A.4
00C9:  MOVLW  21
00CA:  MOVWF  05
00CB:  MOVLW  E3
00CC:  MOVWF  04
00CD:  GOTO   1C2
00CE:  BCF    2A.4
00CF:  BTFSC  29.7
00D0:  GOTO   0DB
00D1:  BTFSS  28.0
00D2:  GOTO   0E6
00D3:  RRF    2E,F
00D4:  RRF    2D,F
00D5:  RRF    2C,F
00D6:  RRF    2B,F
00D7:  INCF   77,F
00D8:  BTFSC  03.2
00D9:  GOTO   1A8
00DA:  GOTO   0E6
00DB:  BTFSC  2E.7
00DC:  GOTO   0E9
00DD:  BCF    03.0
00DE:  RLF    2B,F
00DF:  RLF    2C,F
00E0:  RLF    2D,F
00E1:  RLF    2E,F
00E2:  DECF   77,F
00E3:  BTFSC  03.2
00E4:  GOTO   1A8
00E5:  GOTO   0DB
00E6:  BSF    2A.6
00E7:  GOTO   155
00E8:  BCF    2A.6
00E9:  MOVF   21,W
00EA:  MOVWF  29
00EB:  BTFSS  29.7
00EC:  GOTO   0EF
00ED:  BSF    2E.7
00EE:  GOTO   1A1
00EF:  BCF    2E.7
00F0:  GOTO   1A1
00F1:  MOVF   24,W
00F2:  MOVWF  28
00F3:  MOVWF  77
00F4:  MOVF   20,W
00F5:  SUBWF  28,F
00F6:  MOVF   21,W
00F7:  MOVWF  2E
00F8:  BSF    2E.7
00F9:  MOVF   22,W
00FA:  MOVWF  2D
00FB:  MOVF   23,W
00FC:  MOVWF  2C
00FD:  CLRF   2B
00FE:  BCF    03.0
00FF:  RRF    2E,F
0100:  RRF    2D,F
0101:  RRF    2C,F
0102:  RRF    2B,F
0103:  DECFSZ 28,F
0104:  GOTO   0FD
0105:  BTFSS  29.7
0106:  GOTO   10A
0107:  BSF    2A.1
0108:  GOTO   1AD
0109:  BCF    2A.1
010A:  BCF    28.0
010B:  BSF    2A.5
010C:  MOVLW  21
010D:  MOVWF  05
010E:  MOVLW  E7
010F:  MOVWF  04
0110:  GOTO   1C2
0111:  BCF    2A.5
0112:  BTFSC  29.7
0113:  GOTO   11E
0114:  BTFSS  28.0
0115:  GOTO   129
0116:  RRF    2E,F
0117:  RRF    2D,F
0118:  RRF    2C,F
0119:  RRF    2B,F
011A:  INCF   77,F
011B:  BTFSC  03.2
011C:  GOTO   1A8
011D:  GOTO   129
011E:  BTFSC  2E.7
011F:  GOTO   12C
0120:  BCF    03.0
0121:  RLF    2B,F
0122:  RLF    2C,F
0123:  RLF    2D,F
0124:  RLF    2E,F
0125:  DECF   77,F
0126:  BTFSC  03.2
0127:  GOTO   1A8
0128:  GOTO   11E
0129:  BSF    2A.7
012A:  GOTO   155
012B:  BCF    2A.7
012C:  MOVF   25,W
012D:  MOVWF  29
012E:  BTFSS  29.7
012F:  GOTO   132
0130:  BSF    2E.7
0131:  GOTO   1A1
0132:  BCF    2E.7
0133:  GOTO   1A1
0134:  MOVF   25,W
0135:  MOVWF  2E
0136:  BSF    2E.7
0137:  MOVF   26,W
0138:  MOVWF  2D
0139:  MOVF   27,W
013A:  MOVWF  2C
013B:  BTFSS  29.7
013C:  GOTO   141
013D:  BCF    2E.7
013E:  BSF    2A.2
013F:  GOTO   1AD
0140:  BCF    2A.2
0141:  CLRF   2B
0142:  BCF    28.0
0143:  MOVLW  21
0144:  MOVWF  05
0145:  MOVLW  E3
0146:  MOVWF  04
0147:  GOTO   1C2
0148:  BTFSC  29.7
0149:  GOTO   16B
014A:  MOVF   21,W
014B:  MOVWF  29
014C:  BTFSS  28.0
014D:  GOTO   155
014E:  RRF    2E,F
014F:  RRF    2D,F
0150:  RRF    2C,F
0151:  RRF    2B,F
0152:  INCF   77,F
0153:  BTFSC  03.2
0154:  GOTO   1A8
0155:  BTFSS  2B.7
0156:  GOTO   166
0157:  INCF   2C,F
0158:  BTFSS  03.2
0159:  GOTO   166
015A:  INCF   2D,F
015B:  BTFSS  03.2
015C:  GOTO   166
015D:  INCF   2E,F
015E:  BTFSS  03.2
015F:  GOTO   166
0160:  RRF    2E,F
0161:  RRF    2D,F
0162:  RRF    2C,F
0163:  INCF   77,F
0164:  BTFSC  03.2
0165:  GOTO   1A8
0166:  BTFSC  2A.6
0167:  GOTO   0E8
0168:  BTFSC  2A.7
0169:  GOTO   12B
016A:  GOTO   18A
016B:  MOVLW  80
016C:  XORWF  2E,F
016D:  BTFSS  2E.7
016E:  GOTO   173
016F:  GOTO   1AD
0170:  MOVF   25,W
0171:  MOVWF  29
0172:  GOTO   180
0173:  MOVF   21,W
0174:  MOVWF  29
0175:  MOVF   2E,F
0176:  BTFSS  03.2
0177:  GOTO   180
0178:  MOVF   2D,F
0179:  BTFSS  03.2
017A:  GOTO   180
017B:  MOVF   2C,F
017C:  BTFSS  03.2
017D:  GOTO   180
017E:  CLRF   77
017F:  GOTO   1A1
0180:  BTFSC  2E.7
0181:  GOTO   18A
0182:  BCF    03.0
0183:  RLF    2B,F
0184:  RLF    2C,F
0185:  RLF    2D,F
0186:  RLF    2E,F
0187:  DECFSZ 77,F
0188:  GOTO   180
0189:  GOTO   1A8
018A:  BTFSS  29.7
018B:  GOTO   18E
018C:  BSF    2E.7
018D:  GOTO   1A1
018E:  BCF    2E.7
018F:  GOTO   1A1
0190:  MOVF   24,W
0191:  MOVWF  77
0192:  MOVF   25,W
0193:  MOVWF  2E
0194:  MOVF   26,W
0195:  MOVWF  2D
0196:  MOVF   27,W
0197:  MOVWF  2C
0198:  GOTO   1A1
0199:  MOVF   20,W
019A:  MOVWF  77
019B:  MOVF   21,W
019C:  MOVWF  2E
019D:  MOVF   22,W
019E:  MOVWF  2D
019F:  MOVF   23,W
01A0:  MOVWF  2C
01A1:  MOVF   2E,W
01A2:  MOVWF  78
01A3:  MOVF   2D,W
01A4:  MOVWF  79
01A5:  MOVF   2C,W
01A6:  MOVWF  7A
01A7:  GOTO   1DE
01A8:  CLRF   77
01A9:  CLRF   78
01AA:  CLRF   79
01AB:  CLRF   7A
01AC:  GOTO   1DE
01AD:  CLRF   2B
01AE:  COMF   2C,F
01AF:  COMF   2D,F
01B0:  COMF   2E,F
01B1:  COMF   2B,F
01B2:  INCF   2B,F
01B3:  BTFSS  03.2
01B4:  GOTO   1BB
01B5:  INCF   2C,F
01B6:  BTFSS  03.2
01B7:  GOTO   1BB
01B8:  INCF   2D,F
01B9:  BTFSC  03.2
01BA:  INCF   2E,F
01BB:  BTFSC  2A.0
01BC:  GOTO   0C6
01BD:  BTFSC  2A.1
01BE:  GOTO   109
01BF:  BTFSC  2A.2
01C0:  GOTO   140
01C1:  GOTO   170
01C2:  MOVF   00,W
01C3:  ADDWF  2C,F
01C4:  BTFSS  03.0
01C5:  GOTO   1CC
01C6:  INCF   2D,F
01C7:  BTFSS  03.2
01C8:  GOTO   1CC
01C9:  INCF   2E,F
01CA:  BTFSC  03.2
01CB:  BSF    28.0
01CC:  MOVIW  [--FSR0],W
01CD:  ADDWF  2D,F
01CE:  BTFSS  03.0
01CF:  GOTO   1D3
01D0:  INCF   2E,F
01D1:  BTFSC  03.2
01D2:  BSF    28.0
01D3:  MOVIW  [--FSR0],W
01D4:  BTFSS  00.7
01D5:  XORLW  80
01D6:  ADDWF  2E,F
01D7:  BTFSC  03.0
01D8:  BSF    28.0
01D9:  BTFSC  2A.4
01DA:  GOTO   0CE
01DB:  BTFSC  2A.5
01DC:  GOTO   111
01DD:  GOTO   148
01DE:  MOVLB  00
01DF:  RETURN
*
0242:  MOVF   36,W
0243:  BTFSC  03.2
0244:  GOTO   307
0245:  MOVWF  44
0246:  MOVF   3A,W
0247:  BTFSC  03.2
0248:  GOTO   307
0249:  SUBWF  44,F
024A:  BTFSS  03.0
024B:  GOTO   251
024C:  MOVLW  7F
024D:  ADDWF  44,F
024E:  BTFSC  03.0
024F:  GOTO   307
0250:  GOTO   257
0251:  MOVLW  81
0252:  SUBWF  44,F
0253:  BTFSS  03.0
0254:  GOTO   307
0255:  BTFSC  03.2
0256:  GOTO   307
0257:  MOVF   44,W
0258:  MOVWF  77
0259:  CLRF   78
025A:  CLRF   79
025B:  CLRF   7A
025C:  CLRF   43
025D:  MOVF   37,W
025E:  MOVWF  42
025F:  BSF    42.7
0260:  MOVF   38,W
0261:  MOVWF  41
0262:  MOVF   39,W
0263:  MOVWF  40
0264:  MOVLW  19
0265:  MOVWF  44
0266:  MOVF   3D,W
0267:  SUBWF  40,F
0268:  BTFSC  03.0
0269:  GOTO   27A
026A:  MOVLW  01
026B:  SUBWF  41,F
026C:  BTFSC  03.0
026D:  GOTO   27A
026E:  SUBWF  42,F
026F:  BTFSC  03.0
0270:  GOTO   27A
0271:  SUBWF  43,F
0272:  BTFSC  03.0
0273:  GOTO   27A
0274:  INCF   43,F
0275:  INCF   42,F
0276:  INCF   41,F
0277:  MOVF   3D,W
0278:  ADDWF  40,F
0279:  GOTO   2AC
027A:  MOVF   3C,W
027B:  SUBWF  41,F
027C:  BTFSC  03.0
027D:  GOTO   295
027E:  MOVLW  01
027F:  SUBWF  42,F
0280:  BTFSC  03.0
0281:  GOTO   295
0282:  SUBWF  43,F
0283:  BTFSC  03.0
0284:  GOTO   295
0285:  INCF   43,F
0286:  INCF   42,F
0287:  MOVF   3C,W
0288:  ADDWF  41,F
0289:  MOVF   3D,W
028A:  ADDWF  40,F
028B:  BTFSS  03.0
028C:  GOTO   2AC
028D:  INCF   41,F
028E:  BTFSS  03.2
028F:  GOTO   2AC
0290:  INCF   42,F
0291:  BTFSS  03.2
0292:  GOTO   2AC
0293:  INCF   43,F
0294:  GOTO   2AC
0295:  MOVF   3B,W
0296:  IORLW  80
0297:  SUBWF  42,F
0298:  BTFSC  03.0
0299:  GOTO   2AB
029A:  MOVLW  01
029B:  SUBWF  43,F
029C:  BTFSC  03.0
029D:  GOTO   2AB
029E:  INCF   43,F
029F:  MOVF   3B,W
02A0:  IORLW  80
02A1:  ADDWF  42,F
02A2:  MOVF   3C,W
02A3:  ADDWF  41,F
02A4:  BTFSS  03.0
02A5:  GOTO   289
02A6:  INCF   42,F
02A7:  BTFSS  03.2
02A8:  GOTO   289
02A9:  INCF   43,F
02AA:  GOTO   289
02AB:  BSF    7A.0
02AC:  DECFSZ 44,F
02AD:  GOTO   2AF
02AE:  GOTO   2BA
02AF:  BCF    03.0
02B0:  RLF    40,F
02B1:  RLF    41,F
02B2:  RLF    42,F
02B3:  RLF    43,F
02B4:  BCF    03.0
02B5:  RLF    7A,F
02B6:  RLF    79,F
02B7:  RLF    78,F
02B8:  RLF    45,F
02B9:  GOTO   266
02BA:  BTFSS  45.0
02BB:  GOTO   2C2
02BC:  BCF    03.0
02BD:  RRF    78,F
02BE:  RRF    79,F
02BF:  RRF    7A,F
02C0:  RRF    45,F
02C1:  GOTO   2C5
02C2:  DECF   77,F
02C3:  BTFSC  03.2
02C4:  GOTO   307
02C5:  BTFSC  45.7
02C6:  GOTO   2EE
02C7:  BCF    03.0
02C8:  RLF    40,F
02C9:  RLF    41,F
02CA:  RLF    42,F
02CB:  RLF    43,F
02CC:  MOVF   3D,W
02CD:  SUBWF  40,F
02CE:  BTFSC  03.0
02CF:  GOTO   2DA
02D0:  MOVLW  01
02D1:  SUBWF  41,F
02D2:  BTFSC  03.0
02D3:  GOTO   2DA
02D4:  SUBWF  42,F
02D5:  BTFSC  03.0
02D6:  GOTO   2DA
02D7:  SUBWF  43,F
02D8:  BTFSS  03.0
02D9:  GOTO   2FD
02DA:  MOVF   3C,W
02DB:  SUBWF  41,F
02DC:  BTFSC  03.0
02DD:  GOTO   2E5
02DE:  MOVLW  01
02DF:  SUBWF  42,F
02E0:  BTFSC  03.0
02E1:  GOTO   2E5
02E2:  SUBWF  43,F
02E3:  BTFSS  03.0
02E4:  GOTO   2FD
02E5:  MOVF   3B,W
02E6:  IORLW  80
02E7:  SUBWF  42,F
02E8:  BTFSC  03.0
02E9:  GOTO   2EE
02EA:  MOVLW  01
02EB:  SUBWF  43,F
02EC:  BTFSS  03.0
02ED:  GOTO   2FD
02EE:  INCF   7A,F
02EF:  BTFSS  03.2
02F0:  GOTO   2FD
02F1:  INCF   79,F
02F2:  BTFSS  03.2
02F3:  GOTO   2FD
02F4:  INCF   78,F
02F5:  BTFSS  03.2
02F6:  GOTO   2FD
02F7:  INCF   77,F
02F8:  BTFSC  03.2
02F9:  GOTO   307
02FA:  RRF    78,F
02FB:  RRF    79,F
02FC:  RRF    7A,F
02FD:  MOVF   37,W
02FE:  MOVWF  44
02FF:  MOVF   3B,W
0300:  XORWF  44,F
0301:  BTFSS  44.7
0302:  GOTO   305
0303:  BSF    78.7
0304:  GOTO   30B
0305:  BCF    78.7
0306:  GOTO   30B
0307:  CLRF   77
0308:  CLRF   78
0309:  CLRF   79
030A:  CLRF   7A
*
037E:  MOVLB  05
037F:  MOVF   6D,W
0380:  MOVLB  06
0381:  MOVWF  24
0382:  MOVF   21,W
0383:  XORWF  24,F
0384:  BTFSS  24.7
0385:  GOTO   38D
0386:  BCF    03.2
0387:  BCF    03.0
0388:  MOVLB  05
0389:  BTFSC  6D.7
038A:  BSF    03.0
038B:  GOTO   3DB
038C:  MOVLB  06
038D:  MOVLB  05
038E:  MOVF   6D,W
038F:  MOVLB  06
0390:  MOVWF  24
0391:  MOVF   20,W
0392:  MOVWF  25
0393:  MOVLB  05
0394:  MOVF   6C,W
0395:  MOVLB  06
0396:  SUBWF  25,F
0397:  BTFSC  03.2
0398:  GOTO   3A3
0399:  BTFSC  24.7
039A:  GOTO   39D
039B:  MOVLB  05
039C:  GOTO   3DB
039D:  MOVF   03,W
039E:  XORLW  01
039F:  MOVWF  03
03A0:  MOVLB  05
03A1:  GOTO   3DB
03A2:  MOVLB  06
03A3:  MOVF   21,W
03A4:  MOVWF  25
03A5:  MOVLB  05
03A6:  MOVF   6D,W
03A7:  MOVLB  06
03A8:  SUBWF  25,F
03A9:  BTFSC  03.2
03AA:  GOTO   3B5
03AB:  BTFSC  24.7
03AC:  GOTO   3AF
03AD:  MOVLB  05
03AE:  GOTO   3DB
03AF:  MOVF   03,W
03B0:  XORLW  01
03B1:  MOVWF  03
03B2:  MOVLB  05
03B3:  GOTO   3DB
03B4:  MOVLB  06
03B5:  MOVF   22,W
03B6:  MOVWF  25
03B7:  MOVLB  05
03B8:  MOVF   6E,W
03B9:  MOVLB  06
03BA:  SUBWF  25,F
03BB:  BTFSC  03.2
03BC:  GOTO   3C7
03BD:  BTFSC  24.7
03BE:  GOTO   3C1
03BF:  MOVLB  05
03C0:  GOTO   3DB
03C1:  MOVF   03,W
03C2:  XORLW  01
03C3:  MOVWF  03
03C4:  MOVLB  05
03C5:  GOTO   3DB
03C6:  MOVLB  06
03C7:  MOVF   23,W
03C8:  MOVWF  25
03C9:  MOVLB  05
03CA:  MOVF   6F,W
03CB:  MOVLB  06
03CC:  SUBWF  25,F
03CD:  BTFSC  03.2
03CE:  GOTO   3D9
03CF:  BTFSC  24.7
03D0:  GOTO   3D3
03D1:  MOVLB  05
03D2:  GOTO   3DB
03D3:  MOVF   03,W
03D4:  XORLW  01
03D5:  MOVWF  03
03D6:  MOVLB  05
03D7:  GOTO   3DB
03D8:  MOVLB  06
03D9:  BCF    03.0
03DA:  MOVLB  05
*
0402:  MOVLW  8E
0403:  MOVWF  77
0404:  MOVF   6C,W
0405:  SUBWF  77,F
0406:  MOVF   6D,W
0407:  MOVWF  79
0408:  MOVF   6E,W
0409:  MOVWF  78
040A:  BSF    79.7
040B:  MOVF   77,F
040C:  BTFSC  03.2
040D:  GOTO   419
040E:  BCF    03.0
040F:  MOVF   79,F
0410:  BTFSS  03.2
0411:  GOTO   415
0412:  MOVF   78,F
0413:  BTFSC  03.2
0414:  GOTO   419
0415:  RRF    79,F
0416:  RRF    78,F
0417:  DECFSZ 77,F
0418:  GOTO   40E
0419:  BTFSS  6D.7
041A:  GOTO   420
041B:  COMF   78,F
041C:  COMF   79,F
041D:  INCF   78,F
041E:  BTFSC  03.2
041F:  INCF   79,F
*
064A:  MOVF   38,W
064B:  SUBLW  B6
064C:  MOVWF  38
064D:  CLRF   7A
064E:  MOVF   39,W
064F:  MOVWF  3C
0650:  BSF    39.7
0651:  BCF    03.0
0652:  RRF    39,F
0653:  RRF    3A,F
0654:  RRF    3B,F
0655:  RRF    7A,F
0656:  RRF    79,F
0657:  RRF    78,F
0658:  RRF    77,F
0659:  DECFSZ 38,F
065A:  GOTO   651
065B:  BTFSS  3C.7
065C:  GOTO   668
065D:  COMF   77,F
065E:  COMF   78,F
065F:  COMF   79,F
0660:  COMF   7A,F
0661:  INCF   77,F
0662:  BTFSC  03.2
0663:  INCF   78,F
0664:  BTFSC  03.2
0665:  INCF   79,F
0666:  BTFSC  03.2
0667:  INCF   7A,F
....................  
.................... #list 
....................  
.................... #device ADC=10 
....................  
.................... #FUSES NOMCLR                	//Master Clear pin used for I/O 
.................... #FUSES NOBROWNOUT            	//No brownout reset 
.................... #FUSES NOLVP                 	//No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
....................  
.................... #use delay(crystal=20000000) 
*
01E8:  MOVLW  21
01E9:  MOVWF  05
01EA:  MOVLW  98
01EB:  MOVWF  04
01EC:  MOVF   00,W
01ED:  BTFSC  03.2
01EE:  GOTO   1FC
01EF:  MOVLW  06
01F0:  MOVWF  78
01F1:  CLRF   77
01F2:  DECFSZ 77,F
01F3:  GOTO   1F2
01F4:  DECFSZ 78,F
01F5:  GOTO   1F1
01F6:  MOVLW  7B
01F7:  MOVWF  77
01F8:  DECFSZ 77,F
01F9:  GOTO   1F8
01FA:  DECFSZ 00,F
01FB:  GOTO   1EF
.................... #use rs232(baud=9600,parity=N,xmit=PIN_A2,rcv=PIN_A3,bits=8,stream=PORT1) 
.................... #use i2c(Master,Fast,sda=PIN_C4,scl=PIN_C3) 
*
0679:  MOVLW  08
067A:  MOVWF  78
067B:  NOP
067C:  MOVLB  02
067D:  BCF    0E.3
067E:  MOVLB  01
067F:  BCF    0E.3
0680:  NOP
0681:  MOVLB  05
0682:  RLF    32,F
0683:  MOVLB  02
0684:  BCF    0E.4
0685:  BTFSS  03.0
0686:  GOTO   68A
0687:  MOVLB  01
0688:  BSF    0E.4
0689:  MOVLB  02
068A:  BTFSC  03.0
068B:  GOTO   68F
068C:  MOVLB  01
068D:  BCF    0E.4
068E:  MOVLB  02
068F:  MOVLB  01
0690:  BSF    0E.3
0691:  MOVLB  00
0692:  BTFSS  0E.3
0693:  GOTO   692
0694:  DECFSZ 78,F
0695:  GOTO   67B
0696:  NOP
0697:  MOVLB  02
0698:  BCF    0E.3
0699:  MOVLB  01
069A:  BCF    0E.3
069B:  NOP
069C:  BSF    0E.4
069D:  NOP
069E:  NOP
069F:  BSF    0E.3
06A0:  MOVLB  00
06A1:  BTFSS  0E.3
06A2:  GOTO   6A1
06A3:  CLRF   78
06A4:  NOP
06A5:  BTFSC  0E.4
06A6:  BSF    78.0
06A7:  MOVLB  02
06A8:  BCF    0E.3
06A9:  MOVLB  01
06AA:  BCF    0E.3
06AB:  MOVLB  02
06AC:  BCF    0E.4
06AD:  MOVLB  01
06AE:  BCF    0E.4
06AF:  MOVLB  00
06B0:  RETURN
....................  
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
*
0346:  CLRF   4F
0347:  CLRF   4E
0348:  CLRF   4D
0349:  MOVLW  7F
034A:  MOVWF  4C
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
034B:  MOVLW  7E
034C:  MOVWF  58
034D:  MOVLW  80
034E:  MOVWF  59
034F:  CLRF   5A
0350:  CLRF   5B
0351:  MOVLW  7A
0352:  MOVWF  5C
0353:  MOVLW  2A
0354:  MOVWF  5D
0355:  MOVLW  AA
0356:  MOVWF  5E
0357:  MOVLW  A3
0358:  MOVWF  5F
0359:  MOVLW  75
035A:  MOVWF  60
035B:  MOVLW  B6
035C:  MOVWF  61
035D:  MOVLW  09
035E:  MOVWF  62
035F:  MOVLW  B4
0360:  MOVWF  63
0361:  MOVLW  6F
0362:  MOVWF  64
0363:  MOVLW  4F
0364:  MOVWF  65
0365:  MOVLW  B6
0366:  MOVWF  66
0367:  MOVLW  AA
0368:  MOVWF  67
0369:  MOVLW  69
036A:  MOVWF  68
036B:  MOVLW  8B
036C:  MOVWF  69
036D:  MOVLW  F6
036E:  MOVWF  6A
036F:  MOVLW  E8
0370:  MOVWF  6B
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
0371:  MOVF   43,W
0372:  MOVWF  6F
0373:  MOVF   42,W
0374:  MOVWF  6E
0375:  MOVF   41,W
0376:  MOVWF  6D
0377:  MOVF   40,W
0378:  MOVWF  6C
0379:  MOVLB  06
037A:  CLRF   23
037B:  CLRF   22
037C:  CLRF   21
037D:  CLRF   20
*
03DB:  BTFSS  03.0
03DC:  GOTO   3E0
03DD:  MOVF   41,W
03DE:  XORLW  80
03DF:  MOVWF  41
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
03E0:  MOVF   43,W
03E1:  MOVLB  06
03E2:  MOVWF  23
03E3:  MOVLB  05
03E4:  MOVF   42,W
03E5:  MOVLB  06
03E6:  MOVWF  22
03E7:  MOVLB  05
03E8:  MOVF   41,W
03E9:  MOVLB  06
03EA:  MOVWF  21
03EB:  MOVLB  05
03EC:  MOVF   40,W
03ED:  MOVLB  06
03EE:  MOVWF  20
03EF:  MOVLW  83
03F0:  MOVWF  27
03F1:  MOVLW  F9
03F2:  MOVWF  26
03F3:  MOVLW  22
03F4:  MOVWF  25
03F5:  MOVLW  7E
03F6:  MOVWF  24
03F7:  MOVLB  00
03F8:  CALL   022
03F9:  MOVF   7A,W
03FA:  MOVLB  05
03FB:  MOVWF  6F
03FC:  MOVF   79,W
03FD:  MOVWF  6E
03FE:  MOVF   78,W
03FF:  MOVWF  6D
0400:  MOVF   77,W
0401:  MOVWF  6C
*
0420:  MOVF   78,W
0421:  MOVWF  50
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
0422:  MOVF   43,W
0423:  MOVLB  06
0424:  MOVWF  23
0425:  MOVLB  05
0426:  MOVF   42,W
0427:  MOVLB  06
0428:  MOVWF  22
0429:  MOVLB  05
042A:  MOVF   41,W
042B:  MOVLB  06
042C:  MOVWF  21
042D:  MOVLB  05
042E:  MOVF   40,W
042F:  MOVLB  06
0430:  MOVWF  20
0431:  MOVLW  83
0432:  MOVWF  27
0433:  MOVLW  F9
0434:  MOVWF  26
0435:  MOVLW  22
0436:  MOVWF  25
0437:  MOVLW  7E
0438:  MOVWF  24
0439:  MOVLB  00
043A:  CALL   022
043B:  MOVF   7A,W
043C:  MOVLB  05
043D:  MOVWF  6F
043E:  MOVF   79,W
043F:  MOVWF  6E
0440:  MOVF   78,W
0441:  MOVWF  6D
0442:  MOVF   77,W
0443:  MOVWF  6C
0444:  MOVLB  06
0445:  CLRF   21
0446:  MOVLB  05
0447:  MOVF   50,W
0448:  MOVLB  06
0449:  MOVWF  20
044A:  MOVLB  00
044B:  CALL   003
044C:  BSF    03.1
044D:  MOVLB  05
044E:  MOVF   6F,W
044F:  MOVLB  06
0450:  MOVWF  23
0451:  MOVLB  05
0452:  MOVF   6E,W
0453:  MOVLB  06
0454:  MOVWF  22
0455:  MOVLB  05
0456:  MOVF   6D,W
0457:  MOVLB  06
0458:  MOVWF  21
0459:  MOVLB  05
045A:  MOVF   6C,W
045B:  MOVLB  06
045C:  MOVWF  20
045D:  MOVF   7A,W
045E:  MOVWF  27
045F:  MOVF   79,W
0460:  MOVWF  26
0461:  MOVF   78,W
0462:  MOVWF  25
0463:  MOVF   77,W
0464:  MOVWF  24
0465:  MOVLB  00
0466:  CALL   099
0467:  MOVF   7A,W
0468:  MOVLB  05
0469:  MOVWF  55
046A:  MOVF   79,W
046B:  MOVWF  54
046C:  MOVF   78,W
046D:  MOVWF  53
046E:  MOVF   77,W
046F:  MOVWF  52
....................    quad = quad % 4;                    // quadrant (0 to 3) 
0470:  MOVLW  03
0471:  ANDWF  50,F
....................  
....................    if (quad == 0 || quad == 2) 
0472:  MOVF   50,F
0473:  BTFSC  03.2
0474:  GOTO   479
0475:  MOVF   50,W
0476:  SUBLW  02
0477:  BTFSS  03.2
0478:  GOTO   49C
....................       t = frac * PI_DIV_BY_TWO; 
0479:  MOVF   55,W
047A:  MOVLB  06
047B:  MOVWF  23
047C:  MOVLB  05
047D:  MOVF   54,W
047E:  MOVLB  06
047F:  MOVWF  22
0480:  MOVLB  05
0481:  MOVF   53,W
0482:  MOVLB  06
0483:  MOVWF  21
0484:  MOVLB  05
0485:  MOVF   52,W
0486:  MOVLB  06
0487:  MOVWF  20
0488:  MOVLW  DB
0489:  MOVWF  27
048A:  MOVLW  0F
048B:  MOVWF  26
048C:  MOVLW  49
048D:  MOVWF  25
048E:  MOVLW  7F
048F:  MOVWF  24
0490:  MOVLB  00
0491:  CALL   022
0492:  MOVF   7A,W
0493:  MOVLB  05
0494:  MOVWF  4B
0495:  MOVF   79,W
0496:  MOVWF  4A
0497:  MOVF   78,W
0498:  MOVWF  49
0499:  MOVF   77,W
049A:  MOVWF  48
049B:  GOTO   525
....................    else if (quad == 1) 
049C:  DECFSZ 50,W
049D:  GOTO   4E3
....................       t = (1-frac) * PI_DIV_BY_TWO; 
049E:  BSF    03.1
049F:  MOVLB  06
04A0:  CLRF   23
04A1:  CLRF   22
04A2:  CLRF   21
04A3:  MOVLW  7F
04A4:  MOVWF  20
04A5:  MOVLB  05
04A6:  MOVF   55,W
04A7:  MOVLB  06
04A8:  MOVWF  27
04A9:  MOVLB  05
04AA:  MOVF   54,W
04AB:  MOVLB  06
04AC:  MOVWF  26
04AD:  MOVLB  05
04AE:  MOVF   53,W
04AF:  MOVLB  06
04B0:  MOVWF  25
04B1:  MOVLB  05
04B2:  MOVF   52,W
04B3:  MOVLB  06
04B4:  MOVWF  24
04B5:  MOVLB  00
04B6:  CALL   099
04B7:  MOVF   7A,W
04B8:  MOVLB  05
04B9:  MOVWF  6F
04BA:  MOVF   79,W
04BB:  MOVWF  6E
04BC:  MOVF   78,W
04BD:  MOVWF  6D
04BE:  MOVF   77,W
04BF:  MOVWF  6C
04C0:  MOVF   6F,W
04C1:  MOVLB  06
04C2:  MOVWF  23
04C3:  MOVLB  05
04C4:  MOVF   6E,W
04C5:  MOVLB  06
04C6:  MOVWF  22
04C7:  MOVLB  05
04C8:  MOVF   6D,W
04C9:  MOVLB  06
04CA:  MOVWF  21
04CB:  MOVLB  05
04CC:  MOVF   6C,W
04CD:  MOVLB  06
04CE:  MOVWF  20
04CF:  MOVLW  DB
04D0:  MOVWF  27
04D1:  MOVLW  0F
04D2:  MOVWF  26
04D3:  MOVLW  49
04D4:  MOVWF  25
04D5:  MOVLW  7F
04D6:  MOVWF  24
04D7:  MOVLB  00
04D8:  CALL   022
04D9:  MOVF   7A,W
04DA:  MOVLB  05
04DB:  MOVWF  4B
04DC:  MOVF   79,W
04DD:  MOVWF  4A
04DE:  MOVF   78,W
04DF:  MOVWF  49
04E0:  MOVF   77,W
04E1:  MOVWF  48
04E2:  GOTO   525
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
04E3:  BSF    03.1
04E4:  MOVF   55,W
04E5:  MOVLB  06
04E6:  MOVWF  23
04E7:  MOVLB  05
04E8:  MOVF   54,W
04E9:  MOVLB  06
04EA:  MOVWF  22
04EB:  MOVLB  05
04EC:  MOVF   53,W
04ED:  MOVLB  06
04EE:  MOVWF  21
04EF:  MOVLB  05
04F0:  MOVF   52,W
04F1:  MOVLB  06
04F2:  MOVWF  20
04F3:  CLRF   27
04F4:  CLRF   26
04F5:  CLRF   25
04F6:  MOVLW  7F
04F7:  MOVWF  24
04F8:  MOVLB  00
04F9:  CALL   099
04FA:  MOVF   7A,W
04FB:  MOVLB  05
04FC:  MOVWF  6F
04FD:  MOVF   79,W
04FE:  MOVWF  6E
04FF:  MOVF   78,W
0500:  MOVWF  6D
0501:  MOVF   77,W
0502:  MOVWF  6C
0503:  MOVF   6F,W
0504:  MOVLB  06
0505:  MOVWF  23
0506:  MOVLB  05
0507:  MOVF   6E,W
0508:  MOVLB  06
0509:  MOVWF  22
050A:  MOVLB  05
050B:  MOVF   6D,W
050C:  MOVLB  06
050D:  MOVWF  21
050E:  MOVLB  05
050F:  MOVF   6C,W
0510:  MOVLB  06
0511:  MOVWF  20
0512:  MOVLW  DB
0513:  MOVWF  27
0514:  MOVLW  0F
0515:  MOVWF  26
0516:  MOVLW  49
0517:  MOVWF  25
0518:  MOVLW  7F
0519:  MOVWF  24
051A:  MOVLB  00
051B:  CALL   022
051C:  MOVF   7A,W
051D:  MOVLB  05
051E:  MOVWF  4B
051F:  MOVF   79,W
0520:  MOVWF  4A
0521:  MOVF   78,W
0522:  MOVWF  49
0523:  MOVF   77,W
0524:  MOVWF  48
....................  
....................    y = 1.0; 
0525:  CLRF   47
0526:  CLRF   46
0527:  CLRF   45
0528:  MOVLW  7F
0529:  MOVWF  44
....................    t = t * t; 
052A:  MOVF   4B,W
052B:  MOVLB  06
052C:  MOVWF  23
052D:  MOVLB  05
052E:  MOVF   4A,W
052F:  MOVLB  06
0530:  MOVWF  22
0531:  MOVLB  05
0532:  MOVF   49,W
0533:  MOVLB  06
0534:  MOVWF  21
0535:  MOVLB  05
0536:  MOVF   48,W
0537:  MOVLB  06
0538:  MOVWF  20
0539:  MOVLB  05
053A:  MOVF   4B,W
053B:  MOVLB  06
053C:  MOVWF  27
053D:  MOVLB  05
053E:  MOVF   4A,W
053F:  MOVLB  06
0540:  MOVWF  26
0541:  MOVLB  05
0542:  MOVF   49,W
0543:  MOVLB  06
0544:  MOVWF  25
0545:  MOVLB  05
0546:  MOVF   48,W
0547:  MOVLB  06
0548:  MOVWF  24
0549:  MOVLB  00
054A:  CALL   022
054B:  MOVF   7A,W
054C:  MOVLB  05
054D:  MOVWF  4B
054E:  MOVF   79,W
054F:  MOVWF  4A
0550:  MOVF   78,W
0551:  MOVWF  49
0552:  MOVF   77,W
0553:  MOVWF  48
....................    for (i = 0; i <= 4; i++) 
0554:  CLRF   51
0555:  MOVF   51,W
0556:  SUBLW  04
0557:  BTFSS  03.0
0558:  GOTO   5EA
....................    { 
....................       t2 = t2 * t; 
0559:  MOVF   4F,W
055A:  MOVLB  06
055B:  MOVWF  23
055C:  MOVLB  05
055D:  MOVF   4E,W
055E:  MOVLB  06
055F:  MOVWF  22
0560:  MOVLB  05
0561:  MOVF   4D,W
0562:  MOVLB  06
0563:  MOVWF  21
0564:  MOVLB  05
0565:  MOVF   4C,W
0566:  MOVLB  06
0567:  MOVWF  20
0568:  MOVLB  05
0569:  MOVF   4B,W
056A:  MOVLB  06
056B:  MOVWF  27
056C:  MOVLB  05
056D:  MOVF   4A,W
056E:  MOVLB  06
056F:  MOVWF  26
0570:  MOVLB  05
0571:  MOVF   49,W
0572:  MOVLB  06
0573:  MOVWF  25
0574:  MOVLB  05
0575:  MOVF   48,W
0576:  MOVLB  06
0577:  MOVWF  24
0578:  MOVLB  00
0579:  CALL   022
057A:  MOVF   7A,W
057B:  MOVLB  05
057C:  MOVWF  4F
057D:  MOVF   79,W
057E:  MOVWF  4E
057F:  MOVF   78,W
0580:  MOVWF  4D
0581:  MOVF   77,W
0582:  MOVWF  4C
....................       y = y + p[i] * t2; 
0583:  RLF    51,W
0584:  MOVWF  77
0585:  RLF    77,F
0586:  MOVLW  FC
0587:  ANDWF  77,F
0588:  MOVF   77,W
0589:  ADDLW  C8
058A:  MOVWF  04
058B:  MOVLW  21
058C:  MOVWF  05
058D:  BTFSC  03.0
058E:  INCF   05,F
058F:  MOVF   00,W
0590:  MOVWF  6C
0591:  ADDFSR 01,FSR0
0592:  MOVF   00,W
0593:  MOVWF  6D
0594:  ADDFSR 01,FSR0
0595:  MOVF   00,W
0596:  MOVWF  6E
0597:  ADDFSR 01,FSR0
0598:  MOVF   00,W
0599:  MOVWF  6F
059A:  ADDFSR 3D,FSR0
059B:  MOVF   6F,W
059C:  MOVLB  06
059D:  MOVWF  23
059E:  MOVLB  05
059F:  MOVF   6E,W
05A0:  MOVLB  06
05A1:  MOVWF  22
05A2:  MOVLB  05
05A3:  MOVF   6D,W
05A4:  MOVLB  06
05A5:  MOVWF  21
05A6:  MOVLB  05
05A7:  MOVF   6C,W
05A8:  MOVLB  06
05A9:  MOVWF  20
05AA:  MOVLB  05
05AB:  MOVF   4F,W
05AC:  MOVLB  06
05AD:  MOVWF  27
05AE:  MOVLB  05
05AF:  MOVF   4E,W
05B0:  MOVLB  06
05B1:  MOVWF  26
05B2:  MOVLB  05
05B3:  MOVF   4D,W
05B4:  MOVLB  06
05B5:  MOVWF  25
05B6:  MOVLB  05
05B7:  MOVF   4C,W
05B8:  MOVLB  06
05B9:  MOVWF  24
05BA:  MOVLB  00
05BB:  CALL   022
05BC:  MOVF   05,W
05BD:  MOVLB  05
05BE:  MOVWF  6D
05BF:  MOVF   04,W
05C0:  MOVWF  6C
05C1:  BCF    03.1
05C2:  MOVF   47,W
05C3:  MOVLB  06
05C4:  MOVWF  23
05C5:  MOVLB  05
05C6:  MOVF   46,W
05C7:  MOVLB  06
05C8:  MOVWF  22
05C9:  MOVLB  05
05CA:  MOVF   45,W
05CB:  MOVLB  06
05CC:  MOVWF  21
05CD:  MOVLB  05
05CE:  MOVF   44,W
05CF:  MOVLB  06
05D0:  MOVWF  20
05D1:  MOVF   7A,W
05D2:  MOVWF  27
05D3:  MOVF   79,W
05D4:  MOVWF  26
05D5:  MOVF   78,W
05D6:  MOVWF  25
05D7:  MOVF   77,W
05D8:  MOVWF  24
05D9:  MOVLB  00
05DA:  CALL   099
05DB:  MOVLB  05
05DC:  MOVF   6D,W
05DD:  MOVWF  05
05DE:  MOVF   6C,W
05DF:  MOVWF  04
05E0:  MOVF   7A,W
05E1:  MOVWF  47
05E2:  MOVF   79,W
05E3:  MOVWF  46
05E4:  MOVF   78,W
05E5:  MOVWF  45
05E6:  MOVF   77,W
05E7:  MOVWF  44
05E8:  INCF   51,F
05E9:  GOTO   555
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
05EA:  MOVF   50,W
05EB:  SUBLW  02
05EC:  BTFSC  03.2
05ED:  GOTO   5F0
05EE:  DECFSZ 50,W
05EF:  GOTO   5F3
....................       y = -y;  // correct sign 
05F0:  MOVF   45,W
05F1:  XORLW  80
05F2:  MOVWF  45
....................  
....................    return (y); 
05F3:  MOVF   44,W
05F4:  MOVWF  77
05F5:  MOVF   45,W
05F6:  MOVWF  78
05F7:  MOVF   46,W
05F8:  MOVWF  79
05F9:  MOVF   47,W
05FA:  MOVWF  7A
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
*
031B:  BSF    03.1
031C:  MOVF   39,W
031D:  MOVLB  06
031E:  MOVWF  23
031F:  MOVLB  05
0320:  MOVF   38,W
0321:  MOVLB  06
0322:  MOVWF  22
0323:  MOVLB  05
0324:  MOVF   37,W
0325:  MOVLB  06
0326:  MOVWF  21
0327:  MOVLB  05
0328:  MOVF   36,W
0329:  MOVLB  06
032A:  MOVWF  20
032B:  MOVLW  DB
032C:  MOVWF  27
032D:  MOVLW  0F
032E:  MOVWF  26
032F:  MOVLW  49
0330:  MOVWF  25
0331:  MOVLW  7F
0332:  MOVWF  24
0333:  MOVLB  00
0334:  CALL   099
0335:  MOVF   7A,W
0336:  MOVLB  05
0337:  MOVWF  3F
0338:  MOVF   79,W
0339:  MOVWF  3E
033A:  MOVF   78,W
033B:  MOVWF  3D
033C:  MOVF   77,W
033D:  MOVWF  3C
033E:  MOVF   3F,W
033F:  MOVWF  43
0340:  MOVF   3E,W
0341:  MOVWF  42
0342:  MOVF   3D,W
0343:  MOVWF  41
0344:  MOVF   3C,W
0345:  MOVWF  40
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... /// degiskenler  
.................... int32 sinus_degeri[100]; 
.................... int i ; 
....................   
.................... // pi sayisi tanmlama   
.................... #define PI 3.1415926 
....................  
....................  
.................... void dac_yazdir(unsigned int16 dac_deger) 
.................... { 
....................    i2c_start();                           // i2c haberlesmesi baslatiliyor .  
*
06B1:  MOVLB  01
06B2:  BSF    0E.4
06B3:  NOP
06B4:  BSF    0E.3
06B5:  NOP
06B6:  MOVLB  02
06B7:  BCF    0E.4
06B8:  MOVLB  01
06B9:  BCF    0E.4
06BA:  NOP
06BB:  MOVLB  02
06BC:  BCF    0E.3
06BD:  MOVLB  01
06BE:  BCF    0E.3
....................    i2c_write(0b11000000);                // cihaz adresi  
06BF:  MOVLW  C0
06C0:  MOVLB  05
06C1:  MOVWF  32
06C2:  MOVLB  00
06C3:  CALL   679
....................    i2c_write(0b1000000);                 // dahili adres   
06C4:  MOVLW  40
06C5:  MOVLB  05
06C6:  MOVWF  32
06C7:  MOVLB  00
06C8:  CALL   679
....................    i2c_write((dac_deger & 0xFF0) >> 4);     // yuksek degerlikli bitler kaydiriliyor  8bit (D11.D10.D9.D8.D7.D6.D5.D4) 
06C9:  MOVLB  05
06CA:  MOVF   2E,W
06CB:  ANDLW  F0
06CC:  MOVWF  30
06CD:  MOVF   2F,W
06CE:  ANDLW  0F
06CF:  MOVWF  31
06D0:  RRF    31,F
06D1:  RRF    30,F
06D2:  RRF    31,F
06D3:  RRF    30,F
06D4:  RRF    31,F
06D5:  RRF    30,F
06D6:  RRF    31,F
06D7:  RRF    30,F
06D8:  MOVLW  0F
06D9:  ANDWF  31,F
06DA:  MOVF   30,W
06DB:  MOVWF  32
06DC:  MOVLB  00
06DD:  CALL   679
....................    i2c_write((dac_deger & 0xF) << 4);       //dusuk degerlikli bitler kaydrlyor 4bit    (D3.D2.D1.D0)  
06DE:  MOVLB  05
06DF:  MOVF   2E,W
06E0:  ANDLW  0F
06E1:  MOVWF  30
06E2:  CLRF   31
06E3:  RLF    30,F
06E4:  RLF    31,F
06E5:  RLF    30,F
06E6:  RLF    31,F
06E7:  RLF    30,F
06E8:  RLF    31,F
06E9:  RLF    30,F
06EA:  RLF    31,F
06EB:  MOVLW  F0
06EC:  ANDWF  30,F
06ED:  MOVF   30,W
06EE:  MOVWF  32
06EF:  MOVLB  00
06F0:  CALL   679
....................    i2c_stop();                           // i2c haberlesmesi durduruldu. 
06F1:  MOVLB  01
06F2:  BCF    0E.4
06F3:  NOP
06F4:  BSF    0E.3
06F5:  MOVLB  00
06F6:  BTFSS  0E.3
06F7:  GOTO   6F6
06F8:  NOP
06F9:  GOTO   6FA
06FA:  NOP
06FB:  MOVLB  01
06FC:  BSF    0E.4
06FD:  NOP
06FE:  MOVLP  00
06FF:  MOVLB  00
0700:  GOTO   733 (RETURN)
.................... }  
....................  
....................  
.................... void sinus_hesapla() 
.................... { 
....................    for (i=0; i<100; i++) 
*
01E0:  CLRF   26
01E1:  MOVF   26,W
01E2:  SUBLW  63
01E3:  BTFSS  03.0
01E4:  GOTO   677
....................    { 
....................       delay_ms(100); 
01E5:  MOVLW  64
01E6:  MOVLB  05
01E7:  MOVWF  28
....................       sinus_degeri[i] = ((sin(i*2*PI/100) + 1)*(4096/2)); 
*
01FC:  CLRF   7A
01FD:  MOVLB  00
01FE:  MOVF   26,W
01FF:  MOVWF  79
0200:  RLF    79,F
0201:  RLF    7A,F
0202:  RLF    79,F
0203:  RLF    7A,F
0204:  MOVLW  FC
0205:  ANDWF  79,F
0206:  MOVF   79,W
0207:  ADDLW  08
0208:  MOVWF  78
0209:  MOVLW  20
020A:  ADDWFC 7A,F
020B:  MOVF   78,W
020C:  MOVLB  05
020D:  MOVWF  30
020E:  MOVF   7A,W
020F:  MOVWF  31
0210:  BCF    03.0
0211:  MOVLB  00
0212:  RLF    26,W
0213:  MOVLB  06
0214:  CLRF   21
0215:  MOVWF  20
0216:  MOVLB  00
0217:  CALL   003
0218:  MOVF   7A,W
0219:  MOVLB  06
021A:  MOVWF  23
021B:  MOVF   79,W
021C:  MOVWF  22
021D:  MOVF   78,W
021E:  MOVWF  21
021F:  MOVF   77,W
0220:  MOVWF  20
0221:  MOVLW  DA
0222:  MOVWF  27
0223:  MOVLW  0F
0224:  MOVWF  26
0225:  MOVLW  49
0226:  MOVWF  25
0227:  MOVLW  80
0228:  MOVWF  24
0229:  MOVLB  00
022A:  CALL   022
022B:  MOVF   7A,W
022C:  MOVLB  05
022D:  MOVWF  35
022E:  MOVF   79,W
022F:  MOVWF  34
0230:  MOVF   78,W
0231:  MOVWF  33
0232:  MOVF   77,W
0233:  MOVWF  32
0234:  MOVF   35,W
0235:  MOVWF  39
0236:  MOVF   34,W
0237:  MOVWF  38
0238:  MOVF   33,W
0239:  MOVWF  37
023A:  MOVF   32,W
023B:  MOVWF  36
023C:  CLRF   3D
023D:  CLRF   3C
023E:  MOVLW  48
023F:  MOVWF  3B
0240:  MOVLW  85
0241:  MOVWF  3A
*
030B:  MOVF   7A,W
030C:  MOVWF  35
030D:  MOVF   79,W
030E:  MOVWF  34
030F:  MOVF   78,W
0310:  MOVWF  33
0311:  MOVF   77,W
0312:  MOVWF  32
0313:  MOVF   35,W
0314:  MOVWF  39
0315:  MOVF   34,W
0316:  MOVWF  38
0317:  MOVF   33,W
0318:  MOVWF  37
0319:  MOVF   32,W
031A:  MOVWF  36
*
05FB:  MOVF   7A,W
05FC:  MOVWF  35
05FD:  MOVF   79,W
05FE:  MOVWF  34
05FF:  MOVF   78,W
0600:  MOVWF  33
0601:  MOVF   77,W
0602:  MOVWF  32
0603:  MOVF   05,W
0604:  MOVWF  37
0605:  MOVF   04,W
0606:  MOVWF  36
0607:  BCF    03.1
0608:  MOVF   35,W
0609:  MOVLB  06
060A:  MOVWF  23
060B:  MOVLB  05
060C:  MOVF   34,W
060D:  MOVLB  06
060E:  MOVWF  22
060F:  MOVLB  05
0610:  MOVF   33,W
0611:  MOVLB  06
0612:  MOVWF  21
0613:  MOVLB  05
0614:  MOVF   32,W
0615:  MOVLB  06
0616:  MOVWF  20
0617:  CLRF   27
0618:  CLRF   26
0619:  CLRF   25
061A:  MOVLW  7F
061B:  MOVWF  24
061C:  MOVLB  00
061D:  CALL   099
061E:  MOVLB  05
061F:  MOVF   37,W
0620:  MOVWF  05
0621:  MOVF   36,W
0622:  MOVWF  04
0623:  MOVF   7A,W
0624:  MOVWF  35
0625:  MOVF   79,W
0626:  MOVWF  34
0627:  MOVF   78,W
0628:  MOVWF  33
0629:  MOVF   77,W
062A:  MOVWF  32
062B:  MOVF   35,W
062C:  MOVLB  06
062D:  MOVWF  23
062E:  MOVLB  05
062F:  MOVF   34,W
0630:  MOVLB  06
0631:  MOVWF  22
0632:  MOVLB  05
0633:  MOVF   33,W
0634:  MOVLB  06
0635:  MOVWF  21
0636:  MOVLB  05
0637:  MOVF   32,W
0638:  MOVLB  06
0639:  MOVWF  20
063A:  CLRF   27
063B:  CLRF   26
063C:  CLRF   25
063D:  MOVLW  8A
063E:  MOVWF  24
063F:  MOVLB  00
0640:  CALL   022
0641:  MOVF   7A,W
0642:  MOVLB  05
0643:  MOVWF  3B
0644:  MOVF   79,W
0645:  MOVWF  3A
0646:  MOVF   78,W
0647:  MOVWF  39
0648:  MOVF   77,W
0649:  MOVWF  38
*
0668:  MOVF   31,W
0669:  MOVWF  05
066A:  MOVF   30,W
066B:  MOVWF  04
066C:  MOVF   77,W
066D:  MOVWF  00
066E:  MOVF   78,W
066F:  MOVWI  W,[FSR0+01]
0670:  MOVF   79,W
0671:  MOVWI  W,[FSR0+02]
0672:  MOVF   7A,W
0673:  MOVWI  W,[FSR0+03]
0674:  MOVLB  00
0675:  INCF   26,F
0676:  GOTO   1E1
....................    } 
0677:  MOVLP  00
0678:  GOTO   717 (RETURN)
.................... } 
....................  
.................... void main() 
*
0701:  MOVLB  01
0702:  BCF    0C.2
0703:  MOVLB  02
0704:  BSF    0C.2
0705:  MOVLB  0F
0706:  CLRF   11
0707:  CLRF   12
0708:  CLRF   18
0709:  CLRF   19
070A:  CLRF   1A
070B:  MOVLB  03
070C:  CLRF   0C
070D:  CLRF   0D
070E:  MOVLB  02
070F:  CLRF   12
0710:  CLRF   11
0711:  CLRF   14
0712:  CLRF   13
0713:  MOVLB  00
0714:  CLRF   20
0715:  CLRF   21
.................... { 
....................  
....................    while(TRUE) 
....................    { 
....................  
....................       sinus_hesapla(); 
0716:  GOTO   1E0
....................       dac_yazdir(sinus_degeri[i]); 
0717:  CLRF   7A
0718:  MOVF   26,W
0719:  MOVWF  79
071A:  RLF    79,F
071B:  RLF    7A,F
071C:  RLF    79,F
071D:  RLF    7A,F
071E:  MOVLW  FC
071F:  ANDWF  79,F
0720:  MOVF   79,W
0721:  ADDLW  08
0722:  MOVWF  04
0723:  MOVLW  20
0724:  ADDWFC 7A,W
0725:  MOVWF  05
0726:  MOVF   00,W
0727:  MOVLB  05
0728:  MOVWF  2C
0729:  ADDFSR 01,FSR0
072A:  MOVF   00,W
072B:  MOVWF  2D
072C:  ADDFSR 3F,FSR0
072D:  MOVF   2D,W
072E:  MOVWF  2F
072F:  MOVF   2C,W
0730:  MOVWF  2E
0731:  MOVLB  00
0732:  GOTO   6B1
0733:  GOTO   716
....................  
....................    } 
....................  
.................... } 
0734:  SLEEP

Configuration Fuses:
   Word  1: 3982   HS NOWDT PUT NOMCLR NOPROTECT NOCPD NOBROWNOUT NOCLKOUT IESO FCMEN
   Word  2: 1633   NOWRT NOVCAP PLL_SW STVREN BORV19 NODEBUG NOLVP
